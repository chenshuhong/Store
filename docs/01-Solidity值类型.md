Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要在编译时指定变量的类型。

Solidity 提供了几种基本类型，并且基本类型可以用来组合出复杂类型。

“undefined”或“null”值的概念在Solidity中不存在，但是新声明的变量总是有一个 默认值 ，具体的默认值跟类型相关。

## 值类型

变量将始终按值来传递。 也就是说，当这些变量被用作函数参数或者用在赋值语句中时，总会进行值拷贝。

### 布尔类型

`bool` ：可能的取值为字面常量值 `true` 和 `false` 。

运算符：

- `!` （逻辑非）
- `&&` （逻辑与， “and” ）
- `||` （逻辑或， “or” ）
- `==` （等于）
- `!=` （不等于）

运算符 `||` 和 `&&` 都遵循同样的短路（ short-circuiting ）规则。

### 整形

`int` / `uint` ：分别表示有符号和无符号的不同位数的整型变量。 支持关键字 `uint8` 到 `uint256` （无符号，从 8 位到 256 位）以及 `int8` 到 `int256`，以 `8` 位为步长递增。 `uint` 和 `int` 分别是 `uint256` 和 `int256` 的别名。

#### 比较运算

比较运算符： `<=` ， `<` ， `==` ， `!=` ， `>=` ， `>` （返回布尔值）

#### 位运算

位运算符： `&` ， `|` ， `^` （异或）， `~` （位取反）

#### 移位

移位操作的结果具有左操作数的类型，同时会截断结果以匹配类型。 右操作数必须是无符号类型。 尝试按带符号的类型移动将产生编译错误。

移位可以通过用2的幂的乘法来 “模拟”(方法如下)。请注意，左操作数的截断总是在最后发生，但是不会明确提醒（译者注：应该是指编译器不是提示）。

> 对于移位操作不会像算术运算那样执行溢出检查，其结果总是被截断。

#### 加、减、乘法运算

算数运算符： `+` ， `-` ， 一元运算负 `-` （仅针对有符号整型）， `*` ， `/` ， `%` （取余或叫模运算） ， `**` （幂）

> 算术运算有两个计算模式：一个是 “wrapping”（截断）模式或称 “unchecked”（不检查）模式，一个是”checked” （检查）模式。 默认情况下，算术运算在 “checked” 模式下，即都会进行溢出检查，如果结果落在取值范围之外，调用会通过 失败异常 回退。也可以通过 `unchecked { ... }` 切换到 “unchecked”模式，

### 定长浮点型

`fixed` / `ufixed`：表示各种大小的有符号和无符号的定长浮点型。 在关键字 `ufixedMxN` 和 `fixedMxN` 中，`M` 表示该类型占用的位数，`N` 表示可用的小数位数。 `M` 必须能整除 8，即 8 到 256 位。 `N` 则可以是从 0 到 80 之间的任意数。 `ufixed` 和 `fixed` 分别是 `ufixed128x19` 和 `fixed128x19` 的别名。

