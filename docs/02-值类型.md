Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要在编译时指定变量的类型。

合约中到处充斥着变量，包括状态变量，函数中的变量，结构体的变量等等

“undefined”或“null”值的概念在Solidity中不存在，但是新声明的变量总是有一个 默认值 ，具体的默认值跟类型相关。

关于类型这块，文档写的很清楚了，https://learnblockchain.cn/docs/solidity/types.html，这里总结下常见用法，基本覆盖90%的使用场景

## 值类型

当这些变量被用作函数参数或者用在赋值语句中时，总会进行值拷贝。

### 布尔类型

```solidity
// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.17;

contract BoolType {

    // 默认值false
    bool public bf;
    // 可在定义时赋值
    bool public bt = true;

    // 逻辑非
    function not() public view returns (bool) {
        return !bf;
    }

    // 逻辑与
    function and() public view returns (bool) {
        return bf&&bt;
    }

    // 逻辑或
    function or() public view returns (bool) {
        return bf||bt;
    }

    // 等于
    function equal() public view returns (bool) {
        return bf==bt;
    }

    // 不等于
    function notEqual() public view returns (bool) {
        return bf!=bt;
    }
}
```

![image-20221109161703003](https://gcore.jsdelivr.net/gh/chenshuhong/pic-bed/img/image-20221109161703003.png)

运算符 `||` 和 `&&` 都遵循同样的短路规则。就是说在表达式 `f(x) || g(y)` 中， 如果 `f(x)` 的值为 `true` ，那么 `g(y)` 就不会被执行，即使会出现一些副作用。

### 整型

`int` / `uint` ：分别表示有符号和无符号的不同位数的整型变量。 支持关键字 `uint8` 到 `uint256` （无符号，从 8 位到 256 位）以及 `int8` 到 `int256`，以 `8` 位为步长递增。 `uint` 和 `int` 分别是 `uint256` 和 `int256` 的别名。

对于整形 `X`，可以使用 `type(X).min` 和 `type(X).max` 去获取这个类型的最小值与最大值。

对于int，范围在 -2^255^ 到 2^255^-1之间

对于uint，范围在 0到 2^256^-1之间

```solidity
// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.17;

import "hardhat/console.sol";

contract IntType {
    int public i;
    int public i8;
    int256 public i256;
    uint public ui;
    uint8 public ui8;
    uint256 public ui256;

    function minAndMax() public view {
        console.log("int min value");
        console.logInt(type(int).min);
        console.log("int max value");
        console.logInt(type(int).max);
        console.log("int8 min value");
        console.logInt(type(int8).min);
        console.log("int8 max value");
        console.logInt(type(int8).max);
        console.log("int256 min value");
        console.logInt(type(int256).min);
        console.log("int256 max value");
        console.logInt(type(int256).max);

        console.log("uint min value");
        console.log(type(uint).min);
        console.log("uint max value");
        console.log(type(uint8).max);
        console.log("uint8 min value");
        console.log(type(uint8).min);
        console.log("uint8 max value");
        console.log(type(uint8).max);
        console.log("uint256 min value");
        console.log(type(uint256).min);
        console.log("uint256 max value");
        console.log(type(uint256).max);
    }
}
```

![image-20221110144139723](https://gcore.jsdelivr.net/gh/chenshuhong/pic-bed/img/image-20221110144139723.png)

整形支持

#### 比较

 `<=` ， `<` ， `==` ， `!=` ， `>=` ， `>` （返回布尔值），比较简单，数字之间的大小比较

#### 位运算



#### 移位

有左移和右移，注意由操作数必须是无符号类型，移位的结果类型跟左操作数一致，同时会阶段结果，不会执行溢出检查,结果会被截断

移位可以想象成乘 n 个2或者除以n个2，n为移位的个数，

举个例子，`uint8 a = 3`,实际为 `00000011`,我们左移移位，即，a<<1,那么就会变成`00000110`,是6，6刚好是3的2倍，所以，二进制左移一位，其实就是将数字翻倍。那左移两位，就是翻倍再翻倍。

右移一位，就是去除末尾的那一位， a>>1,那么就会变成`00000011`,是3，`3>>1`,就是`00000001`,是1,1。所以二进制右移一位，就是将数字除以 2 并求整数商的操作。

当然以上是在不考虑溢出的情况

uint8 `01111111` 左移一位，是`11111110`,还没溢出，左移两位，`111111100`,溢出，截掉超过的位，变成`11111100`,是 252，

```solidity
 function moveBit() public view{
        uint8 ui8 = 127;
        console.log("left move 127,move 1",ui8<<1);
        console.log("left move 127,move 2",ui8<<2);
        console.log("left move 127,move 3",ui8<<3);
        console.log("right move 127,move 1",ui8>>1);
        console.log("right move 127,move 2",ui8>>2);
        console.log("right move 127,move 6",ui8>>6);
        console.log("right move 127,move 7",ui8>>7);
        console.log("right move 127,move 8",ui8>>8);
    }
```

![image-20221110182822716](https://gcore.jsdelivr.net/gh/chenshuhong/pic-bed/img/image-20221110182822716.png)

#### 算数运算

加法，减法和乘法和通常理解的语义一样，不过有两种模式来应对溢出（上溢及下溢）

默认情况下，算术运算都会进行溢出检查，但是也可以禁用检查，可以通过 unchecked block 来禁用检查，此时会返回截断的结果

```solidity
    function calcOver() public view{
        uint8 a = 2;
        uint8 b=3;
        unchecked { uint8 c = a-b;console.log('unchecked value:',c); }
        uint8 d = a-b;
        console.log(d);
    }
```

![image-20221110172505847](https://gcore.jsdelivr.net/gh/chenshuhong/pic-bed/img/image-20221110172505847.png)

可以看到，如果使用uncheck，那么会截断，2-3，实际上是 00000010-00000011，这里涉及到计算机

### 定长浮点型

### 地址类型Address

### 定长字节数组

### 枚举类型

#### 函数类型

